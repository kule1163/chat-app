//stackoverflow.com/questions/39881194/allow-one-concurrent-user-per-login-with-jwt

https: import express from "express";
import cors from "cors";
import mongoose from "mongoose";
import bodyParser from "body-parser";
import dotenv from "dotenv";
import authRoute from "./routes/auth";
import chatRoute from "./routes/chat";
import messageRoute from "./routes/message";
import { Server } from "socket.io";
import { Chat, User } from "../../my-app/src/features/types";
import axios from "axios";

const app = express();

dotenv.config();

app.use(
  "/uploads/profilePhotos",
  express.static(__dirname + "/uploads/profilePhotos")
);
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors());

app.use("/auth", authRoute);
app.use("/chat", chatRoute);
app.use("/message", messageRoute);

const CONNETION_URL =
  "mongodb+srv://kule1163:thv8pyyx4z@cluster0.zjlbe.mongodb.net/chatApp?retryWrites=true&w=majority";
const PORT = 5000;

interface OnlineUser {
  socketId: string;
  email: string;
  id: string;
}

let onlineUsers: OnlineUser[] = [];

mongoose
  .connect(CONNETION_URL)
  .then(() => {
    const server = app.listen(PORT, () =>
      console.log(`server is listening ${PORT}`)
    );
    const io = new Server(server, {
      pingTimeout: 60000,
      cors: {
        origin: "http://localhost:3000",
      },
    });
    io.on("connection", (socket) => {
      console.log("Connected to socket.io");
      socket.on("setup", (userData) => {
        if (userData) {
          socket.join(userData._id);

          socket.emit("connected", socket.id);

          const currentUser = onlineUsers.find(
            (item) => item.id === userData._id
          );

          if (!currentUser) {
            onlineUsers.push({
              email: userData.email,
              socketId: socket.id,
              id: userData._id,
            });

            console.log("socket.id", socket.id);

            socket.broadcast.emit("reconnection", userData.email);
          } else {
            console.log("in ekse", {
              email: userData.email,
              socketId: socket.id,
              id: userData._id,
            });
            socket.broadcast.emit(
              "dont allow another login",
              currentUser.socketId
            );

            currentUser.socketId = socket.id;
            console.log("socket.id", socket.id);

            console.log("current user updated", currentUser.socketId);

            /*             socket.disconnect(true);
             */
          }

          console.log("onlineUsersonlineUsers", onlineUsers);
        }
      });

      socket.on("disconnect", async () => {
        if (onlineUsers.length === 1) {
          try {
            await axios.post("http://localhost:5000/auth/online-statu", {
              email: onlineUsers[0].email,
              statu: "offline",
            });

            onlineUsers = onlineUsers.filter(
              (item) => item.socketId !== socket.id
            );

            console.log("disdisdisdis", onlineUsers);
          } catch (error) {
            console.log(error);
          }
        } else {
          const currentUser = onlineUsers.find(
            (item) => item.socketId === socket.id
          );
          if (currentUser) {
            console.log("user disconnect", currentUser);

            socket.broadcast.emit("user disconnect", currentUser.email);
            onlineUsers = onlineUsers.filter(
              (item) => item.socketId !== socket.id
            );
          }
        }
        console.log("disssssssss ", onlineUsers);
      });

      socket.on("handle online", (user: User) => {
        console.log("user", user);

        socket.broadcast.emit("user statu", user);
      });

      socket.on("join chat", (room) => {
        socket.join(room);
      });
      socket.on("typing", (room) => {
        socket.in(room._id).emit("typing", room._id);
      });
      socket.on("stop typing", (room) =>
        socket.in(room._id).emit("stop typing")
      );

      socket.on("new message", (newMessageRecieved) => {
        var chat: Chat = newMessageRecieved.chat;

        if (!chat.users) return console.log("chat.users not defined");

        chat.users.forEach((user) => {
          if (user._id == newMessageRecieved.sender._id) return;

          socket.in(user._id).emit("message recieved", newMessageRecieved);
        });
      });
      interface AccessChatProps {
        chat: Chat;
        sender: string;
      }
      socket.on("access chat", ({ chat, sender }: AccessChatProps) => {
        if (chat && sender) {
          chat.users.forEach((user) => {
            if (user._id == sender) return;

            socket.broadcast.to(user._id).emit("get chat", chat);
          });
        }
      });
    });
  })
  .catch((err) => console.log(err.message));
